<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>H·ªá Th·ªëng H·∫°t 3D - ƒêi·ªÅu Khi·ªÉn B·∫±ng Tay</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            height: 100vh;
        }

        #container {
            position: relative;
            width: 100%;
            height: 100vh;
        }

        #canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #video {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            border-radius: 15px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            transform: scaleX(-1);
            z-index: 10;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            z-index: 10;
            min-width: 280px;
            max-height: 85vh;
            overflow-y: auto;
        }

        #controls h2 {
            color: white;
            font-size: 18px;
            margin-bottom: 15px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            color: white;
            font-size: 14px;
            margin-bottom: 8px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        #colorPicker {
            width: 100%;
            height: 40px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .shape-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 10px;
        }

        .shape-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            padding: 10px 6px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
            text-align: center;
        }

        .shape-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .shape-btn.active {
            background: rgba(255, 255, 255, 0.4);
            border-color: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        }

        #status {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 14px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
            z-index: 10;
            text-align: center;
            max-width: 80%;
        }

        .info-box {
            background: rgba(255, 255, 255, 0.1);
            padding: 12px;
            border-radius: 8px;
            color: white;
            font-size: 11px;
            line-height: 1.6;
        }

        .info-box strong {
            display: block;
            margin-bottom: 5px;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            text-align: center;
            z-index: 100;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .gesture-mode {
            background: rgba(255, 255, 255, 0.15);
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
        }

        .gesture-mode label {
            display: flex;
            align-items: center;
            color: white;
            font-size: 13px;
            cursor: pointer;
        }

        .gesture-mode input {
            margin-right: 8px;
        }

        .slider-container {
            margin-top: 10px;
        }

        .slider-container input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.3);
            outline: none;
        }

        .slider-container input[type="range"]::-webkit-slider-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
        }

        .gesture-guide {
            background: rgba(255, 200, 0, 0.2);
            border: 2px solid rgba(255, 200, 0, 0.5);
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
        }

        .gesture-guide h3 {
            color: #FFD700;
            font-size: 13px;
            margin-bottom: 8px;
        }

        .gesture-item {
            color: white;
            font-size: 11px;
            margin: 4px 0;
            padding-left: 10px;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        <div>ƒêang kh·ªüi t·∫°o camera...</div>
    </div>

    <div id="container">
        <canvas id="canvas"></canvas>
        <video id="video" autoplay playsinline></video>
        
        <div id="controls">
            <h2>‚öôÔ∏è ƒêi·ªÅu Khi·ªÉn</h2>
            
            <div class="control-group">
                <label for="colorPicker">üé® M√†u H·∫°t:</label>
                <input type="color" id="colorPicker" value="#00ffff">
            </div>

            <div class="control-group">
                <label>üî∑ Ch·ªçn H√¨nh D·∫°ng:</label>
                <div class="shape-buttons">
                    <button class="shape-btn active" data-shape="sphere">‚ö™ C·∫ßu</button>
                    <button class="shape-btn" data-shape="cube">üü¶ H·ªôp</button>
                    <button class="shape-btn" data-shape="torus">üç© Xuy·∫øn</button>
                    <button class="shape-btn" data-shape="helix">üåÄ Xo·∫Øn</button>
                    <button class="shape-btn" data-shape="wave">üåä S√≥ng</button>
                    <button class="shape-btn" data-shape="heart">‚ù§Ô∏è Tr√°i Tim</button>
                    <button class="shape-btn" data-shape="spiral">üå™Ô∏è Xo·∫Øn ·ªêc</button>
                    <button class="shape-btn" data-shape="galaxy">üåå Thi√™n H√†</button>
                    <button class="shape-btn" data-shape="pyramid">üî∫ Kim T·ª± Th√°p</button>
                    <button class="shape-btn" data-shape="star">‚≠ê Ng√¥i Sao</button>
                    <button class="shape-btn" data-shape="dna">üß¨ DNA</button>
                    <button class="shape-btn" data-shape="flower">üå∏ Hoa</button>
                    <button class="shape-btn" data-shape="infinity">‚ôæÔ∏è V√¥ C·ª±c</button>
                    <button class="shape-btn" data-shape="tornado">üå™Ô∏è L·ªëc Xo√°y</button>
                    <button class="shape-btn" data-shape="diamond">üíé Kim C∆∞∆°ng</button>
                    <button class="shape-btn" data-shape="ring">üíç Nh·∫´n</button>
                </div>
            </div>

            <div class="gesture-mode">
                <label>
                    <input type="checkbox" id="gestureMode" checked>
                    ü§ö ƒêi·ªÅu khi·ªÉn b·∫±ng tay
                </label>
            </div>

            <div class="control-group slider-container">
                <label for="sizeSlider">üìè K√≠ch Th∆∞·ªõc: <span id="sizeValue">5</span></label>
                <input type="range" id="sizeSlider" min="2" max="12" value="5" step="0.5">
            </div>

            <div class="control-group slider-container">
                <label for="speedSlider">‚ö° T·ªëc ƒê·ªô Xoay: <span id="speedValue">1x</span></label>
                <input type="range" id="speedSlider" min="0" max="3" value="1" step="0.1">
            </div>

            <div class="gesture-guide">
                <h3>üéØ C·ª≠ Ch·ªâ Tay:</h3>
                <div class="gesture-item">‚úåÔ∏è <strong>Ch·ªØ V:</strong> TƒÉng t·ªëc xoay</div>
                <div class="gesture-item">üëç <strong>Like:</strong> Ph√≥ng to</div>
                <div class="gesture-item">üëé <strong>Dislike:</strong> Thu nh·ªè</div>
                <div class="gesture-item">üëä <strong>N·∫Øm tay tr√°i:</strong> Xoay tr√°i</div>
                <div class="gesture-item">üëä <strong>N·∫Øm tay ph·∫£i:</strong> Xoay ph·∫£i</div>
                <div class="gesture-item">üñêÔ∏è <strong>X√≤e 2 tay:</strong> M·ªü r·ªông</div>
                <div class="gesture-item">ü§è <strong>Kh√©p 2 tay:</strong> Thu g·ªçn</div>
                <div class="gesture-item">‚òùÔ∏è <strong>1 ng√≥n:</strong> Chuy·ªÉn h√¨nh ng·∫´u nhi√™n</div>
                <div class="gesture-item">ü§ò <strong>Rock:</strong> ƒê·ªïi m√†u ng·∫´u nhi√™n</div>
            </div>
        </div>

        <div id="status">ü§ö Ch·ªù ph√°t hi·ªán tay...</div>
    </div>

    <script>
        // Three.js setup
        let scene, camera, renderer, particles, particleSystem;
        let targetRadius = 5;
        let currentRadius = 5;
        const particleCount = 3000;
        let particleColor = new THREE.Color(0x00ffff);
        let currentShape = 'sphere';
        let rotationSpeed = 0.001;
        let targetRotationY = 0;
        let targetRotationX = 0;
        let targetPositionY = 0;
        let lastGesture = '';
        let gestureTimeout = null;

        // Shape generation functions
        const shapes = {
            sphere: (i, total, r) => {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                return {
                    x: r * Math.sin(phi) * Math.cos(theta),
                    y: r * Math.sin(phi) * Math.sin(theta),
                    z: r * Math.cos(phi)
                };
            },
            cube: (i, total, r) => {
                return {
                    x: (Math.random() - 0.5) * r * 2,
                    y: (Math.random() - 0.5) * r * 2,
                    z: (Math.random() - 0.5) * r * 2
                };
            },
            torus: (i, total, r) => {
                const theta = (i / total) * Math.PI * 2 * 5;
                const phi = Math.random() * Math.PI * 2;
                const R = r;
                const tube = r * 0.4;
                return {
                    x: (R + tube * Math.cos(phi)) * Math.cos(theta),
                    y: (R + tube * Math.cos(phi)) * Math.sin(theta),
                    z: tube * Math.sin(phi)
                };
            },
            helix: (i, total, r) => {
                const t = (i / total) * Math.PI * 8;
                return {
                    x: r * Math.cos(t),
                    y: (i / total - 0.5) * r * 4,
                    z: r * Math.sin(t)
                };
            },
            wave: (i, total, r) => {
                const x = ((i % 50) / 50 - 0.5) * r * 2;
                const z = (Math.floor(i / 50) / 60 - 0.5) * r * 2;
                const y = Math.sin(x * 2) * Math.cos(z * 2) * r * 0.5;
                return { x, y, z };
            },
            heart: (i, total, r) => {
                const t = (i / total) * Math.PI * 2;
                const u = Math.random() * Math.PI;
                const scale = r * 0.5;
                return {
                    x: scale * (16 * Math.pow(Math.sin(t), 3)),
                    y: scale * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)),
                    z: scale * Math.sin(u) * 5
                };
            },
            spiral: (i, total, r) => {
                const t = (i / total) * Math.PI * 10;
                const radius = r * (i / total);
                return {
                    x: radius * Math.cos(t),
                    y: (i / total - 0.5) * r * 3,
                    z: radius * Math.sin(t)
                };
            },
            galaxy: (i, total, r) => {
                const arm = i % 3;
                const t = (i / total) * Math.PI * 4;
                const radius = r * Math.pow(i / total, 0.5);
                const angle = t + arm * (Math.PI * 2 / 3);
                return {
                    x: radius * Math.cos(angle) + (Math.random() - 0.5) * 0.5,
                    y: (Math.random() - 0.5) * r * 0.3,
                    z: radius * Math.sin(angle) + (Math.random() - 0.5) * 0.5
                };
            },
            pyramid: (i, total, r) => {
                const layer = Math.floor(Math.sqrt(i / total) * 10);
                const angle = (i % 20) / 20 * Math.PI * 2;
                const radius = (10 - layer) / 10 * r;
                return {
                    x: radius * Math.cos(angle),
                    y: (layer / 10 - 0.5) * r * 2,
                    z: radius * Math.sin(angle)
                };
            },
            star: (i, total, r) => {
                const t = (i / total) * Math.PI * 2;
                const spikes = 5;
                const outerRadius = r;
                const innerRadius = r * 0.5;
                const angle = t * spikes;
                const radius = (Math.floor(angle / Math.PI) % 2) ? innerRadius : outerRadius;
                const height = (Math.random() - 0.5) * r * 0.5;
                return {
                    x: radius * Math.cos(t),
                    y: height,
                    z: radius * Math.sin(t)
                };
            },
            dna: (i, total, r) => {
                const t = (i / total) * Math.PI * 10;
                const strand = i % 2;
                const offset = strand * Math.PI;
                return {
                    x: r * Math.cos(t + offset),
                    y: (i / total - 0.5) * r * 4,
                    z: r * Math.sin(t + offset)
                };
            },
            flower: (i, total, r) => {
                const t = (i / total) * Math.PI * 2;
                const petals = 8;
                const petalRadius = Math.abs(Math.sin(petals * t)) * r;
                const height = Math.cos(petals * t) * r * 0.3;
                return {
                    x: petalRadius * Math.cos(t),
                    y: height,
                    z: petalRadius * Math.sin(t)
                };
            },
            infinity: (i, total, r) => {
                const t = (i / total) * Math.PI * 2;
                const scale = r * 0.8;
                return {
                    x: scale * Math.cos(t) / (1 + Math.sin(t) * Math.sin(t)),
                    y: scale * Math.sin(t) * Math.cos(t) / (1 + Math.sin(t) * Math.sin(t)),
                    z: (Math.random() - 0.5) * r * 0.3
                };
            },
            tornado: (i, total, r) => {
                const t = (i / total) * Math.PI * 8;
                const height = (i / total) * r * 3;
                const radius = r * (1 - i / total);
                return {
                    x: radius * Math.cos(t),
                    y: height - r * 1.5,
                    z: radius * Math.sin(t)
                };
            },
            diamond: (i, total, r) => {
                const layer = Math.floor(i / (total / 3));
                const t = (i % (total / 3)) / (total / 3) * Math.PI * 2;
                const layerRadius = layer === 1 ? r : r * 0.5;
                const y = layer === 0 ? r : (layer === 1 ? 0 : -r);
                return {
                    x: layerRadius * Math.cos(t),
                    y: y,
                    z: layerRadius * Math.sin(t)
                };
            },
            ring: (i, total, r) => {
                const t = (i / total) * Math.PI * 2;
                const ringRadius = r * 1.2;
                const tubeRadius = r * 0.2;
                const phi = Math.random() * Math.PI * 2;
                return {
                    x: (ringRadius + tubeRadius * Math.cos(phi)) * Math.cos(t),
                    y: tubeRadius * Math.sin(phi),
                    z: (ringRadius + tubeRadius * Math.cos(phi)) * Math.sin(t)
                };
            }
        };

        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 15;

            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('canvas'),
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);

            createParticles();

            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);

            animate();
        }

        function createParticles() {
            if (particleSystem) {
                scene.remove(particleSystem);
            }

            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const originalPositions = [];

            for (let i = 0; i < particleCount; i++) {
                const pos = shapes[currentShape](i, particleCount, 3);
                positions.push(pos.x, pos.y, pos.z);
                originalPositions.push(pos.x, pos.y, pos.z);
                colors.push(particleColor.r, particleColor.g, particleColor.b);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.15,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);

            particles = {
                positions: geometry.attributes.position.array,
                originalPositions: originalPositions
            };
        }

        function animate() {
            requestAnimationFrame(animate);

            currentRadius += (targetRadius - currentRadius) * 0.05;
            particleSystem.rotation.y += rotationSpeed;
            particleSystem.rotation.x += rotationSpeed * 0.5;
            
            particleSystem.rotation.y += (targetRotationY - particleSystem.rotation.y) * 0.1;
            particleSystem.rotation.x += (targetRotationX - particleSystem.rotation.x) * 0.1;
            particleSystem.position.y += (targetPositionY - particleSystem.position.y) * 0.1;

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const scale = currentRadius / 3;

                particles.positions[i3] = particles.originalPositions[i3] * scale;
                particles.positions[i3 + 1] = particles.originalPositions[i3 + 1] * scale;
                particles.positions[i3 + 2] = particles.originalPositions[i3 + 2] * scale;
            }

            particleSystem.geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }

        // MediaPipe Hands
        let hands, cameraStream;
        let leftHand = null;
        let rightHand = null;

        function initMediaPipe() {
            hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }
            });

            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onResults);

            const videoElement = document.getElementById('video');
            
            navigator.mediaDevices.getUserMedia({ 
                video: { 
                    width: 640, 
                    height: 480,
                    facingMode: 'user'
                } 
            })
            .then(stream => {
                videoElement.srcObject = stream;
                cameraStream = new Camera(videoElement, {
                    onFrame: async () => {
                        await hands.send({ image: videoElement });
                    },
                    width: 640,
                    height: 480
                });
                cameraStream.start();
                document.getElementById('loading').style.display = 'none';
            })
            .catch(err => {
                console.error('Camera error:', err);
                document.getElementById('loading').innerHTML = '‚ùå Kh√¥ng th·ªÉ truy c·∫≠p camera';
            });
        }

        function onResults(results) {
            if (!document.getElementById('gestureMode').checked) return;

            leftHand = null;
            rightHand = null;

            if (results.multiHandLandmarks && results.multiHandedness) {
                for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                    const hand = results.multiHandedness[i].label;
                    const landmarks = results.multiHandLandmarks[i];

                    if (hand === 'Left') {
                        leftHand = landmarks;
                    } else {
                        rightHand = landmarks;
                    }
                }

                updateParticles();
            } else {
                document.getElementById('status').textContent = 'ü§ö Ch·ªù ph√°t hi·ªán tay...';
            }
        }

        function isFistClosed(hand) {
            if (!hand) return false;
            const fingerTips = [8, 12, 16, 20];
            const palm = hand[0];
            let closedCount = 0;
            
            for (let tip of fingerTips) {
                const dx = hand[tip].x - palm.x;
                const dy = hand[tip].y - palm.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < 0.1) closedCount++;
            }
            
            return closedCount >= 3;
        }

        function detectGesture(hand) {
            if (!hand) return null;

            const thumb = hand[4];
            const index = hand[8];
            const middle = hand[12];
            const ring = hand[16];
            const pinky = hand[20];
            const palm = hand[0];

            // Calculate distances
            const indexUp = index.y < palm.y - 0.1;
            const middleUp = middle.y < palm.y - 0.1;
            const ringUp = ring.y < palm.y - 0.1;
            const pinkyUp = pinky.y < palm.y - 0.1;
            const thumbUp = thumb.y < palm.y - 0.05;

            const indexDist = Math.sqrt((index.x - palm.x)**2 + (index.y - palm.y)**2);
            const middleDist = Math.sqrt((middle.x - palm.x)**2 + (middle.y - palm.y)**2);

            // Peace sign (V)
            if (indexUp && middleUp && !ringUp && !pinkyUp) {
                return 'peace';
            }

            // Thumbs up
            if (thumbUp && !indexUp && !middleUp && !ringUp && !pinkyUp) {
                return 'thumbsup';
            }

            // Thumbs down
            if (thumb.y > palm.y + 0.1 && !indexUp && !middleUp && !ringUp && !pinkyUp) {
                return 'thumbsdown';
            }

            // One finger
            if (indexUp && !middleUp && !ringUp && !pinkyUp) {
                return 'one';
            }

            // Rock sign
            if (indexUp && pinkyUp && !middleUp && !ringUp) {
                return 'rock';
            }

            // Fist
            if (isFistClosed(hand)) {
                return 'fist';
            }

            return null;
        }

        function handleGesture(gesture, hand) {
            if (gesture === lastGesture) return;
            
            clearTimeout(gestureTimeout);
            lastGesture = gesture;

            gestureTimeout = setTimeout(() => {
                lastGesture = '';
            }, 1000);

            switch(gesture) {
                case 'peace':
                    rotationSpeed = 0.005;
                    document.getElementById('speedSlider').value = 3;
                    document.getElementById('speedValue').textContent = '3.0x';
                    break;
                case 'thumbsup':
                    targetRadius = Math.min(targetRadius + 2, 12);
                    break;
                case 'thumbsdown':
                    targetRadius = Math.max(targetRadius - 2, 2);
                    break;
                case 'one':
                    const shapeNames = Object.keys(shapes);
                    const randomShape = shapeNames[Math.floor(Math.random() * shapeNames.length)];
                    currentShape = randomShape;
                    createParticles();
                    document.querySelectorAll('.shape-btn').forEach(btn => {
                        btn.classList.toggle('active', btn.dataset.shape === randomShape);
                    });
                    break;
                case 'rock':
                    const randomColor = '#' + Math.floor(Math.random()*16777215).toString(16);
                    document.getElementById('colorPicker').value = randomColor;
                    particleColor.set(randomColor);
                    const colors = particleSystem.geometry.attributes.color.array;
                    for (let i = 0; i < colors.length; i += 3) {
                        colors[i] = particleColor.r;
                        colors[i + 1] = particleColor.g;
                        colors[i + 2] = particleColor.b;
                    }
                    particleSystem.geometry.attributes.color.needsUpdate = true;
                    break;
            }
        }

        function updateParticles() {
            let statusText = '';
            const hand = leftHand || rightHand;

            // Detect gestures
            if (hand) {
                const gesture = detectGesture(hand);
                if (gesture) {
                    handleGesture(gesture, hand);
                    const gestureNames = {
                        'peace': '‚úåÔ∏è Ch·ªØ V - TƒÉng t·ªëc',
                        'thumbsup': 'üëç Like - Ph√≥ng to',
                        'thumbsdown': 'üëé Dislike - Thu nh·ªè',
                        'one': '‚òùÔ∏è 1 ng√≥n - ƒê·ªïi h√¨nh',
                        'rock': 'ü§ò Rock - ƒê·ªïi m√†u',
                        'fist': 'üëä N·∫Øm tay'
                    };
                    statusText = gestureNames[gesture] || '';
                }
            }

            if (leftHand && rightHand) {
                const leftWrist = leftHand[0];
                const rightWrist = rightHand[0];

                const dx = leftWrist.x - rightWrist.x;
                const dy = leftWrist.y - rightWrist.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                targetRadius = 2 + distance * 15;
                targetRadius = Math.max(2, Math.min(targetRadius, 12));
                document.getElementById('sizeSlider').value = targetRadius;
                document.getElementById('sizeValue').textContent = targetRadius.toFixed(1);

                const leftFist = isFistClosed(leftHand);
                const rightFist = isFistClosed(rightHand);

                if (leftFist && !statusText) {
                    targetRotationY -= 0.05;
                    statusText = 'üëä Xoay tr√°i';
                }
                if (rightFist && !statusText) {
                    targetRotationY += 0.05;
                    statusText = 'üëä Xoay ph·∫£i';
                }

                const avgY = (leftWrist.y + rightWrist.y) / 2;
                targetPositionY = (0.5 - avgY) * 10;

                if (!statusText) {
                    const status = distance > 0.4 ? 'üåü M·ªü r·ªông' : '‚ö™ Thu g·ªçn';
                    statusText = status;
                }
                
                document.getElementById('status').textContent = `‚úã‚úã ${statusText}`;
            } else if (hand) {
                const wrist = hand[0];
                targetPositionY = (0.5 - wrist.y) * 10;
                
                if (!statusText) {
                    document.getElementById('status').textContent = 'üëã Ph√°t hi·ªán 1 tay - D√πng c·ª≠ ch·ªâ ho·∫∑c th√™m tay th·ª© 2';
                } else {
                    document.getElementById('status').textContent = 'üëã ' + statusText;
                }
            }
        }

        // UI Controls
        document.getElementById('colorPicker').addEventListener('input', (e) => {
            particleColor.set(e.target.value);
            const colors = particleSystem.geometry.attributes.color.array;
            for (let i = 0; i < colors.length; i += 3) {
                colors[i] = particleColor.r;
                colors[i + 1] = particleColor.g;
                colors[i + 2] = particleColor.b;
            }
            particleSystem.geometry.attributes.color.needsUpdate = true;
        });

        document.querySelectorAll('.shape-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentShape = btn.dataset.shape;
                createParticles();
            });
        });

        document.getElementById('sizeSlider').addEventListener('input', (e) => {
            if (!document.getElementById('gestureMode').checked) {
                targetRadius = parseFloat(e.target.value);
                document.getElementById('sizeValue').textContent = targetRadius.toFixed(1);
            }
        });

        document.getElementById('speedSlider').addEventListener('input', (e) => {
            const speed = parseFloat(e.target.value);
            rotationSpeed = speed * 0.001;
            document.getElementById('speedValue').textContent = speed.toFixed(1) + 'x';
        });

        document.getElementById('gestureMode').addEventListener('change', (e) => {
            if (!e.target.checked) {
                document.getElementById('status').textContent = 'üñ±Ô∏è Ch·∫ø ƒë·ªô th·ªß c√¥ng - D√πng thanh tr∆∞·ª£t';
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        initThree();
        initMediaPipe();
    </script>
</body>
</html>